// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AaveLend extends ethereum.Event {
  get params(): AaveLend__Params {
    return new AaveLend__Params(this);
  }
}

export class AaveLend__Params {
  _event: AaveLend;

  constructor(event: AaveLend) {
    this._event = event;
  }

  get amount(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class ChainlinkCancelled extends ethereum.Event {
  get params(): ChainlinkCancelled__Params {
    return new ChainlinkCancelled__Params(this);
  }
}

export class ChainlinkCancelled__Params {
  _event: ChainlinkCancelled;

  constructor(event: ChainlinkCancelled) {
    this._event = event;
  }

  get id(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class ChainlinkFulfilled extends ethereum.Event {
  get params(): ChainlinkFulfilled__Params {
    return new ChainlinkFulfilled__Params(this);
  }
}

export class ChainlinkFulfilled__Params {
  _event: ChainlinkFulfilled;

  constructor(event: ChainlinkFulfilled) {
    this._event = event;
  }

  get id(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class ChainlinkRequested extends ethereum.Event {
  get params(): ChainlinkRequested__Params {
    return new ChainlinkRequested__Params(this);
  }
}

export class ChainlinkRequested__Params {
  _event: ChainlinkRequested;

  constructor(event: ChainlinkRequested) {
    this._event = event;
  }

  get id(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class MarketResolved extends ethereum.Event {
  get params(): MarketResolved__Params {
    return new MarketResolved__Params(this);
  }
}

export class MarketResolved__Params {
  _event: MarketResolved;

  constructor(event: MarketResolved) {
    this._event = event;
  }

  get blockNumber(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get isResolved(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class NewPrediction extends ethereum.Event {
  get params(): NewPrediction__Params {
    return new NewPrediction__Params(this);
  }
}

export class NewPrediction__Params {
  _event: NewPrediction;

  constructor(event: NewPrediction) {
    this._event = event;
  }

  get predictor(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get prediction(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get stake(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Withdrawn extends ethereum.Event {
  get params(): Withdrawn__Params {
    return new Withdrawn__Params(this);
  }
}

export class Withdrawn__Params {
  _event: Withdrawn;

  constructor(event: Withdrawn) {
    this._event = event;
  }

  get withdrawer(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class PredictionMarket extends ethereum.SmartContract {
  static bind(address: Address): PredictionMarket {
    return new PredictionMarket("PredictionMarket", address);
  }

  amountStaked(param0: Address): BigInt {
    let result = super.call("amountStaked", "amountStaked(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_amountStaked(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "amountStaked",
      "amountStaked(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getATokenBalance(): BigInt {
    let result = super.call(
      "getATokenBalance",
      "getATokenBalance():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getATokenBalance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getATokenBalance",
      "getATokenBalance():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getBorrowRate(): BigInt {
    let result = super.call("getBorrowRate", "getBorrowRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getBorrowRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getBorrowRate",
      "getBorrowRate():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getDAIBalance(): BigInt {
    let result = super.call("getDAIBalance", "getDAIBalance():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getDAIBalance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getDAIBalance",
      "getDAIBalance():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLendingRate(): BigInt {
    let result = super.call("getLendingRate", "getLendingRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getLendingRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLendingRate",
      "getLendingRate():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRewardAmount(_address: Address): BigInt {
    let result = super.call(
      "getRewardAmount",
      "getRewardAmount(address):(uint256)",
      [ethereum.Value.fromAddress(_address)]
    );

    return result[0].toBigInt();
  }

  try_getRewardAmount(_address: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRewardAmount",
      "getRewardAmount(address):(uint256)",
      [ethereum.Value.fromAddress(_address)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isAlreadyWithdrawn(param0: Address): boolean {
    let result = super.call(
      "isAlreadyWithdrawn",
      "isAlreadyWithdrawn(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_isAlreadyWithdrawn(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isAlreadyWithdrawn",
      "isAlreadyWithdrawn(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isLessRisky(): boolean {
    let result = super.call("isLessRisky", "isLessRisky():(bool)", []);

    return result[0].toBoolean();
  }

  try_isLessRisky(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isLessRisky", "isLessRisky():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isMarketResolved(): boolean {
    let result = super.call(
      "isMarketResolved",
      "isMarketResolved():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_isMarketResolved(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isMarketResolved",
      "isMarketResolved():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isStakedOnAave(): boolean {
    let result = super.call("isStakedOnAave", "isStakedOnAave():(bool)", []);

    return result[0].toBoolean();
  }

  try_isStakedOnAave(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isStakedOnAave", "isStakedOnAave():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  marketCloseTimestamp(): BigInt {
    let result = super.call(
      "marketCloseTimestamp",
      "marketCloseTimestamp():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_marketCloseTimestamp(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "marketCloseTimestamp",
      "marketCloseTimestamp():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  options(param0: BigInt): Bytes {
    let result = super.call("options", "options(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBytes();
  }

  try_options(param0: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall("options", "options(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  optionsCount(): i32 {
    let result = super.call("optionsCount", "optionsCount():(uint8)", []);

    return result[0].toI32();
  }

  try_optionsCount(): ethereum.CallResult<i32> {
    let result = super.tryCall("optionsCount", "optionsCount():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  prediction(param0: Address): Bytes {
    let result = super.call("prediction", "prediction(address):(bytes32)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBytes();
  }

  try_prediction(param0: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall("prediction", "prediction(address):(bytes32)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  predictionCloseTimestamp(): BigInt {
    let result = super.call(
      "predictionCloseTimestamp",
      "predictionCloseTimestamp():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_predictionCloseTimestamp(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "predictionCloseTimestamp",
      "predictionCloseTimestamp():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  predictionResult(): Bytes {
    let result = super.call(
      "predictionResult",
      "predictionResult():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_predictionResult(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "predictionResult",
      "predictionResult():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  question(): string {
    let result = super.call("question", "question():(string)", []);

    return result[0].toString();
  }

  try_question(): ethereum.CallResult<string> {
    let result = super.tryCall("question", "question():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  token(): Address {
    let result = super.call("token", "token():(address)", []);

    return result[0].toAddress();
  }

  try_token(): ethereum.CallResult<Address> {
    let result = super.tryCall("token", "token():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tokenWithInterest(): BigInt {
    let result = super.call(
      "tokenWithInterest",
      "tokenWithInterest():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_tokenWithInterest(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenWithInterest",
      "tokenWithInterest():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalAmountStaked(): BigInt {
    let result = super.call(
      "totalAmountStaked",
      "totalAmountStaked():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_totalAmountStaked(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalAmountStaked",
      "totalAmountStaked():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  uniquePredictionValue(param0: Bytes): BigInt {
    let result = super.call(
      "uniquePredictionValue",
      "uniquePredictionValue(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBigInt();
  }

  try_uniquePredictionValue(param0: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "uniquePredictionValue",
      "uniquePredictionValue(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _isLessRisky(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get _question(): string {
    return this._call.inputValues[2].value.toString();
  }

  get _options(): Array<Bytes> {
    return this._call.inputValues[3].value.toBytesArray();
  }

  get _optionsCount(): i32 {
    return this._call.inputValues[4].value.toI32();
  }

  get _resultApi(): string {
    return this._call.inputValues[5].value.toString();
  }

  get _resultPath(): string {
    return this._call.inputValues[6].value.toString();
  }

  get _marketCloseTimestamp(): BigInt {
    return this._call.inputValues[7].value.toBigInt();
  }

  get _predictionCloseTimestamp(): BigInt {
    return this._call.inputValues[8].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class FulfillCall extends ethereum.Call {
  get inputs(): FulfillCall__Inputs {
    return new FulfillCall__Inputs(this);
  }

  get outputs(): FulfillCall__Outputs {
    return new FulfillCall__Outputs(this);
  }
}

export class FulfillCall__Inputs {
  _call: FulfillCall;

  constructor(call: FulfillCall) {
    this._call = call;
  }

  get _requestId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _data(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class FulfillCall__Outputs {
  _call: FulfillCall;

  constructor(call: FulfillCall) {
    this._call = call;
  }
}

export class LendOnAaveCall extends ethereum.Call {
  get inputs(): LendOnAaveCall__Inputs {
    return new LendOnAaveCall__Inputs(this);
  }

  get outputs(): LendOnAaveCall__Outputs {
    return new LendOnAaveCall__Outputs(this);
  }
}

export class LendOnAaveCall__Inputs {
  _call: LendOnAaveCall;

  constructor(call: LendOnAaveCall) {
    this._call = call;
  }
}

export class LendOnAaveCall__Outputs {
  _call: LendOnAaveCall;

  constructor(call: LendOnAaveCall) {
    this._call = call;
  }
}

export class MakePredictionCall extends ethereum.Call {
  get inputs(): MakePredictionCall__Inputs {
    return new MakePredictionCall__Inputs(this);
  }

  get outputs(): MakePredictionCall__Outputs {
    return new MakePredictionCall__Outputs(this);
  }
}

export class MakePredictionCall__Inputs {
  _call: MakePredictionCall;

  constructor(call: MakePredictionCall) {
    this._call = call;
  }

  get _prediction(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _stakeAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class MakePredictionCall__Outputs {
  _call: MakePredictionCall;

  constructor(call: MakePredictionCall) {
    this._call = call;
  }
}

export class ResolveMarketCall extends ethereum.Call {
  get inputs(): ResolveMarketCall__Inputs {
    return new ResolveMarketCall__Inputs(this);
  }

  get outputs(): ResolveMarketCall__Outputs {
    return new ResolveMarketCall__Outputs(this);
  }
}

export class ResolveMarketCall__Inputs {
  _call: ResolveMarketCall;

  constructor(call: ResolveMarketCall) {
    this._call = call;
  }
}

export class ResolveMarketCall__Outputs {
  _call: ResolveMarketCall;

  constructor(call: ResolveMarketCall) {
    this._call = call;
  }
}

export class WithdrawRewardCall extends ethereum.Call {
  get inputs(): WithdrawRewardCall__Inputs {
    return new WithdrawRewardCall__Inputs(this);
  }

  get outputs(): WithdrawRewardCall__Outputs {
    return new WithdrawRewardCall__Outputs(this);
  }
}

export class WithdrawRewardCall__Inputs {
  _call: WithdrawRewardCall;

  constructor(call: WithdrawRewardCall) {
    this._call = call;
  }
}

export class WithdrawRewardCall__Outputs {
  _call: WithdrawRewardCall;

  constructor(call: WithdrawRewardCall) {
    this._call = call;
  }
}
